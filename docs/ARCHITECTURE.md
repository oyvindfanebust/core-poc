# Architecture Documentation

This document describes the architectural decisions, design patterns, and system design of the Banking Ledger POC.

## Architecture Principles

### Domain-Driven Design

The system follows Domain-Driven Design (DDD) principles with clear separation of concerns:

- **Domain Layer**: Core business logic and entities
- **Repository Layer**: Data access abstraction
- **Service Layer**: Business operations and workflows
- **Controller Layer**: HTTP request/response handling

### Data Storage Strategy

#### TigerBeetle (Financial Data)

- **Purpose**: ALL financial transactions and balances
- **Ports**: 6000-6001 (development/test)
- **Benefits**:
  - High-performance accounting database
  - ACID compliance for financial operations
  - Built-in double-entry bookkeeping
  - Immutable transaction history

#### PostgreSQL (Metadata)

- **Purpose**: Non-financial metadata ONLY
- **Port**: 5432
- **Storage**:
  - Account metadata (customer info, account types)
  - User authentication data
  - Configuration settings
  - **NEVER financial balances or transactions**

#### JSON Configuration Files

- **Purpose**: System account mappings
- **Location**: `config/system-accounts.json`
- **Benefits**:
  - Simple deployment and backup
  - Version control friendly
  - Atomic file operations

## Design Patterns

### Repository Pattern

Clean data access abstraction separating business logic from data persistence:

```typescript
interface AccountRepository {
  create(account: Account): Promise<void>;
  findById(id: AccountId): Promise<Account | null>;
  findByCustomerId(customerId: CustomerId): Promise<Account[]>;
}
```

### Value Objects

Type-safe financial primitives ensuring data integrity:

- **Money**: Always integers (cents), never decimals
- **AccountId**: Type-safe account identifiers
- **CustomerId**: Validated customer identifiers

### Factory Pattern

Service instantiation and dependency injection through factory classes:

```typescript
// Service factories handle dependency injection
const serviceFactory = new ServiceFactory(config);
const accountService = serviceFactory.getAccountService();
```

### Command Pattern

Background job processing with clear separation of concerns:

```typescript
interface PaymentJob {
  execute(): Promise<void>;
}
```

## System Architecture

### Dual Account ID Scheme

The system implements two types of account identifiers to support both customer and system accounts:

#### Customer Accounts

- **Format**: Numeric IDs generated by TigerBeetle (e.g., `123456789`)
- **Usage**: Regular customer deposit, loan, and credit accounts
- **Storage**: Account metadata in PostgreSQL, financial data in TigerBeetle

#### System Accounts

- **Format**: Prefixed string identifiers (e.g., `SYSTEM-EXTERNAL-USD`, `SEPA-OUT-SUSPENSE-EUR`)
- **Types**:
  - `SYSTEM-EQUITY-{CURRENCY}` - Equity accounts for external transactions
  - `SYSTEM-LIABILITY-{CURRENCY}` - Liability accounts for system operations
  - `SEPA-OUT-SUSPENSE-{CURRENCY}` - SEPA outgoing transfer suspense
  - `SEPA-IN-SUSPENSE-{CURRENCY}` - SEPA incoming transfer suspense
  - `SEPA-SETTLEMENT-{CURRENCY}` - SEPA settlement accounts
- **Mapping**: String identifiers mapped to TigerBeetle numeric IDs via configuration file
- **Persistence**: `config/system-accounts.json` stores identifier-to-numeric-ID mappings

### SEPA Suspense Account Flow

#### Outgoing Transfer

1. **Customer Initiates**: Customer Account → SEPA Outgoing Suspense → SEPA Settlement
2. **External Processing**: SEPA Settlement → External Bank

#### Incoming Transfer

1. **External Source**: External Bank → SEPA Settlement → SEPA Incoming Suspense
2. **Customer Credit**: SEPA Incoming Suspense → Customer Account

#### Internal Transfer

- **Direct**: Customer Account A → Customer Account B (no suspense accounts)

## Technology Decisions

### Why TigerBeetle?

- **Performance**: Optimized for high-frequency financial transactions
- **ACID Compliance**: Ensures data consistency for financial operations
- **Double-Entry Bookkeeping**: Built-in accounting principles
- **Audit Trail**: Immutable transaction history
- **Zero Downtime**: Hot standby and replication support

### Why PostgreSQL?

- **Reliability**: ACID transactions and data integrity
- **Scalability**: Excellent performance for analytical queries
- **JSON Support**: Flexible data storage when needed
- **Ecosystem**: Rich tooling and monitoring support
- **Compliance**: Well-understood for financial applications

### Why Next.js for Frontend?

- **Performance**: Server-side rendering and static generation
- **Developer Experience**: Built-in TypeScript support
- **Internationalization**: First-class i18n support
- **Ecosystem**: Rich component and tooling ecosystem

## Service Architecture

### Core API (Port 7001)

- **Responsibility**: Main REST API for banking operations
- **Technologies**: Node.js, Express, TypeScript
- **Features**: Account management, transfers, loan processing

### Customer Frontend (Port 7002)

- **Responsibility**: Customer-facing web application
- **Technologies**: Next.js, React, Tailwind CSS
- **Features**: Account viewing, transfer initiation, loan management

### Batch Processor (Port 7003)

- **Responsibility**: Background job processing
- **Technologies**: Node.js, TypeScript
- **Features**: Payment processing, invoice generation, cleanup jobs

## Data Flow Architecture

### Request Flow

1. **Client Request**: Frontend or API client sends request
2. **Validation**: Zod schemas validate input data
3. **Service Layer**: Business logic processes request
4. **Repository Layer**: Data access through repositories
5. **Storage**: Financial data to TigerBeetle, metadata to PostgreSQL
6. **Response**: Structured response back to client

### Background Job Flow

1. **Scheduler**: Triggers background jobs based on schedule
2. **Job Queue**: Jobs queued for processing
3. **Worker Process**: Background processor executes jobs
4. **Data Updates**: Updates both TigerBeetle and PostgreSQL
5. **Logging**: Comprehensive logging of job execution

## Security Architecture

### Input Validation

- **Zod Schemas**: Runtime type validation for all API inputs
- **Sanitization**: Input sanitization to prevent injection attacks
- **Type Safety**: TypeScript compile-time type checking

### Data Protection

- **Parameterized Queries**: SQL injection prevention
- **Error Handling**: No sensitive data leaked in error responses
- **Audit Logging**: Comprehensive logging of all financial operations

### Authentication & Authorization

- **Ready for Implementation**: Middleware structure in place
- **Session Management**: Framework for user session handling
- **Role-Based Access**: Prepared for role-based permissions

## Scalability Considerations

### Horizontal Scaling

- **Stateless Services**: All services designed to be stateless
- **Load Balancing**: Ready for load balancer deployment
- **Database Connections**: Connection pooling for efficient resource usage

### Performance Optimization

- **Background Processing**: Non-blocking job execution
- **Caching Strategy**: Ready for Redis integration
- **Database Optimization**: Indexed queries and optimized schema

### Monitoring & Observability

- **Health Checks**: Comprehensive health monitoring
- **Metrics Collection**: Prometheus-compatible metrics
- **Structured Logging**: JSON logging for log aggregation
- **Correlation IDs**: Request tracing across services
